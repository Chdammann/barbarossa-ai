<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Frag Friedrich Barbarossa</title>

<link rel="icon" href="avatar.png" type="image/png">
<link rel="apple-touch-icon" href="avatar.png">
<meta name="theme-color" content="#000000">

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: "Georgia", serif;
    color: white;
  }
  h1 {
    position: absolute;
    top: 20px;
    width: 100%;
    text-align: center;
    font-size: 2em;
    color: #e0b36b;
    animation: pulse 3s ease-in-out infinite;
  }
  @keyframes pulse {
    0%,100% { opacity: 1; }
    50% { opacity: 0.85; }
  }
  #avatarCanvas { width:100%; height:100%; display:block; }
  #micBtn {
    position:absolute;
    bottom:60px;
    left:50%;
    transform:translateX(-50%);
    width:80px;
    height:80px;
    border-radius:50%;
    border:none;
    background:#222;
    color:white;
    font-size:32px;
    cursor:pointer;
  }
  #micBtn:hover { background:#444; }
  #loading {
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    color:#ccc;
    font-size:1.1em;
    text-align:center;
  }
</style>
</head>

<body>
<h1>Frag Friedrich</h1>
<div id="loading">Avatar wird geladen‚Ä¶</div>
<canvas id="avatarCanvas"></canvas>
<button id="micBtn">üé§</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
/* -----------------------------
   STATE-VARIABLEN + SICHERHEIT
----------------------------- */

// === Hauptzust√§nde ===
let model, STATE = "idle";
let lastTranscript = "";
let talking = false, greeted = false;

// === Bewegungszust√§nde ===
let frontalFix = true;              // nach Laden: noch nicht frontal
let hmNeigen   = false, hmStartTime = 0;
let rising     = false, riseStartTime = 0;

// ‚≠ê R√ºckkehr nach rechts ‚Äì nur am ENDE gesteuert!
let toIdlePose   = false, toIdleStart = 0;
const toIdleDuration = 3000;        // sanfte R√ºckkehr (kann z.B. 3000 sein)

// === Animationszeiten (ms) ===
const hmDuration   = 8000;         // Hmmm sehr langsam
const riseDuration = 3000;          // Begr√º√üung / Antwort ‚Üí frontal

// === Grundposition Avatar ===
let baseRotY = -0.35;               // leicht nach rechts geneigt
let baseRotX = 0.25;
let baseY = 0;

// üõ°Ô∏è NIEMALS gleichzeitig mehrere Bewegungen
// ‚ùó Wichtig: toIdlePose DARF NICHT hier gel√∂scht werden,
// denn es wird nur von der StateMachine gesetzt!
function resetMovements() {
  hmNeigen = false;
  rising   = false;
  talking  = false;
}
  /* ====== AudioContext f√ºr SpeechSynthesis (Lipsync) ====== */
let audioCtx, audioAnalyser, audioDataArray;

function initTTSAnalyser() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  audioAnalyser = audioCtx.createAnalyser();
  audioAnalyser.fftSize = 2048;
  audioDataArray = new Uint8Array(audioAnalyser.frequencyBinCount);

  console.log("üîä TTS-Analyser aktiviert");
}

function getTTSVolume() {
  if (!audioAnalyser) return 0;

  audioAnalyser.getByteFrequencyData(audioDataArray);
  let sum = 0;
  for (let i = 0; i < audioDataArray.length; i++) sum += audioDataArray[i];
  return sum / audioDataArray.length / 255;  // 0‚Äì1 Lautst√§rke
}

// üîÑ AUFRUF EINMAL beim Start
initTTSAnalyser();

/* -----------------------------
   THREE.js SETUP
----------------------------- */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  30,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 0, 2.8);

const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById("avatarCanvas"),
  antialias: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(0x000000);

/* LICHT ‚Äì KORREKT */
const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(1, 1, 2);
scene.add(dirLight);

const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambLight);

const frontLight = new THREE.PointLight(0xffffff, 0.8);
frontLight.position.set(0, 0.5, 2);
scene.add(frontLight);

/* --------------------------------------------------
   MODEL LADEN  (mit Blendshape-Erkennung)
-------------------------------------------------- */
let visemeAIndex = null;      // global definiert ‚Äì oben im Code!
let visemeEIndex = null;      // global definiert ‚Äì oben im Code!

const loader = new THREE.GLTFLoader();
loader.load("./avatar.glb", gltf => {
  model = gltf.scene;

  // Gr√∂√üe / Position wie bisher
  const box = new THREE.Box3().setFromObject(model);
  const size = box.getSize(new THREE.Vector3());
  model.scale.setScalar((1.5 / Math.max(size.x, size.y, size.z)) * 0.8);
  const center = box.getCenter(new THREE.Vector3());
  model.position.sub(center);

  baseY = model.position.y;
  model.rotation.y = baseRotY - Math.PI / 2;
  model.rotation.x = baseRotX;

  /* --------------------------------------------
     üîé BLENDSHAPES AUTOMATISCH FINDEN
  -------------------------------------------- */
  model.traverse(obj => {
    if (obj.isMesh && obj.morphTargetDictionary) {

      // Blendshapes einmal in Console anzeigen:
      console.log("Mesh:", obj.name, obj.morphTargetDictionary);

      if (obj.morphTargetDictionary["Viseme_A"] !== undefined) {
        visemeAIndex = obj.morphTargetDictionary["Viseme_A"];
      }

      if (obj.morphTargetDictionary["Viseme_E"] !== undefined) {
        visemeEIndex = obj.morphTargetDictionary["Viseme_E"];
      }
    }
  });

  console.log("üü¢ Viseme_A Index:", visemeAIndex, 
              "| Viseme_E Index:", visemeEIndex);


  /* -------------------------- */
  scene.add(model);
  document.getElementById("loading").style.display = "none";

  animate();
});
/* === Blendshape setzen === */
function setBlendshape(index, value) {
  model.traverse(obj => {
    if (obj.isMesh && obj.morphTargetInfluences && index !== null) {
      obj.morphTargetInfluences[index] = value;
    }
  });
}

/* -----------------------------------
   ANIMATE ‚Äì FINAL & STABLE
----------------------------------- */
function animate() {
  requestAnimationFrame(animate);
  if (!model) return;

  const now = performance.now();
  const frontalY = -Math.PI / 2;               // frontal
  const rightY   = baseRotY - Math.PI / 2;     // Startpose rechts
  const leftY    = frontalY + 0.25;            // Hmmm = leicht links

  // 0Ô∏è‚É£ START: Ausgangsposition (leicht rechts)
  if (frontalFix) {
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, rightY, 0.08);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, baseRotX, 0.08);
    renderer.render(scene, camera);
    return;
  }

  // 1Ô∏è‚É£ GREET / ANTWORTBEGINN ‚Üí FRONTAL
  if (rising) {
    const t = (now - riseStartTime) / riseDuration;
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, frontalY, 0.06);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, 0, 0.06);
    if (t >= 1) rising = false;
  }

  // 2Ô∏è‚É£ HMMM ‚Üí LANGSAM LINKS
  else if (hmNeigen) {
    const t = Math.min(1, (now - hmStartTime) / hmDuration);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, baseRotX + 0.25, t);
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, leftY, t);
  }

  // 3Ô∏è‚É£ ANTWORT ‚Üí FRONTAL
  else if (STATE === "answer") {
    model.position.y = baseY + Math.sin(now * 0.0015) * 0.008;
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, frontalY, 0.03);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, 0, 0.03);
  }

  // 4Ô∏è‚É£ TALKING = SPRICHT ‚Üí FRONTAL & ATMEN
  else if (talking) {
    model.position.y = baseY + Math.sin(now * 0.0015) * 0.008;
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, frontalY, 0.03);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, 0, 0.03);
  }

  // 5Ô∏è‚É£ WARTET AUF FRAGE ‚Üí FRONTAL
  else if (STATE === "listen" || STATE === "greet") {
    model.position.y = baseY + Math.sin(now * 0.0012) * 0.006;
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, frontalY, 0.03);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, 0, 0.03);
  }

  // 6Ô∏è‚É£ ENDE ‚Üí SANFT ZUR√úCK NACH RECHTS
else if (STATE === "idle" && !talking && !rising) {
  const breathSpeed = 0.0011 + Math.sin(now * 0.00005) * 0.0004;
  const breathAmp   = 0.006  + Math.sin(now * 0.00008) * 0.003;
  model.position.y  = baseY + Math.sin(now * breathSpeed) * breathAmp;

  model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, rightY, 0.03);
  model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, baseRotX, 0.03);
}

// ‚≠ê Sichtbare, nat√ºrliche Blickbewegungen ‚Äì Version 2 (mehr Dynamik!)
const driftX = Math.sin(now * 0.0012) * 0.05;   // klar sichtbares Nicken
const driftY = Math.sin(now * 0.0010) * 0.04;   // klar seitlich ‚Äûdenken‚Äú

// X-Achse ‚Üí Richtung baseRotX + Variation
model.rotation.x = THREE.MathUtils.lerp(
  model.rotation.x,
  baseRotX + driftX,
  0.03          // schnellere Reaktion
);

// Y-Achse ‚Üí nur wenn kein Hmmm aktiv (NICHT Antwort unterbrechen!)
if (!hmNeigen && !rising) {
  model.rotation.y = THREE.MathUtils.lerp(
    model.rotation.y,
    model.rotation.y + driftY,
    0.018
  );
}

renderer.render(scene, camera);
}
  
/* -----------------------------
   STATE MACHINE ‚Äì LOGIK (FINAL)
----------------------------- */

let recognition;
if ("webkitSpeechRecognition" in window) {
  recognition = new webkitSpeechRecognition();
  recognition.lang = "de-DE";
  recognition.continuous = false;

  // Ergebnis speichern:
  recognition.onresult = e => {
    lastTranscript = e.results[0][0].transcript;
  };

  // Aufnahme beendet:
  recognition.onend = () => {
    if (STATE === "listen" && lastTranscript) {

      // 1Ô∏è‚É£ HMMM ‚Äì Kopf langsam nach links:
      resetMovements();
      STATE = "hmmm";
      hmNeigen = true;
      hmStartTime = performance.now();
      speak("√Ñ√§mmmmmmmmm..... einen Moment", true);

      // Mindestwartezeit einhalten:
      const MIN_HMMM = 4000;
      setTimeout(() => {

        fetch("/ask", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: lastTranscript })
        })
        .then(r => r.json())
        .then(data => {

          // 2Ô∏è‚É£ ANTWORT BEGINNT ‚Üí frontal
          resetMovements();
          STATE = "answer";
          rising = true;
          riseStartTime = performance.now();
          speak(data.answer);

          // 3Ô∏è‚É£ ANTWORT FERTIG ‚Üí jetzt erst zur√ºck nach rechts!
          const waitUntilDone = setInterval(() => {
            if (!talking && !rising) {
              clearInterval(waitUntilDone);
              resetMovements();
              greeted = false;
              STATE = "idle";

              // ‚≠ê TRIGGER ‚Üí block 4 aktiviert RECHTS-NEIGUNG!
              toIdlePose = true;
              toIdleStart = performance.now();
            }
          }, 200);
        })
        .catch(() => {
          resetMovements();
          STATE = "idle";
        });

      }, MIN_HMMM);

    } else {
      resetMovements();
      STATE = "idle";
    }
  };
}
   /* -----------------------------
   BUTTON ‚Äì GREET & LISTEN
----------------------------- */
document.getElementById("micBtn").onclick = () => {

  // Erste Bet√§tigung ‚Üí Begr√º√üung
  if (!greeted) {
    resetMovements();
    greeted = true;
    STATE = "greet";

    frontalFix = false;               // ab jetzt Bewegung erlaubt
    rising = true;
    riseStartTime = performance.now();

    speak(
      "Seid gegr√º√üt, mein Freund. Ich bin Friedrich Barbarossa, nach fast neunhundert Jahren im Kaiserberg zu Lautern erwacht. Was ist Euer Begehr?",
      false
    );
    return;
  }

  // Sp√§tere Bet√§tigung ‚Üí Spracherkennung starten
  if (!recognition) {
    alert("Spracherkennung wird nicht unterst√ºtzt.");
    return;
  }

  resetMovements();
  lastTranscript = "";
  STATE = "listen";
  recognition.start();
};

/* -----------------------------
   1) M√ÑNNLICHE STIMME FEST SETZEN  (GLOBAL!)
----------------------------- */
let maleVoice = null;

function setMaleVoice() {
  const voices = speechSynthesis.getVoices();

  if (!voices.length) {
    setTimeout(setMaleVoice, 150);
    return;
  }

  maleVoice = voices.find(v => v.name === "Microsoft Stefan - German (Germany)");
  console.log("Ausgew√§hlte Stimme:", maleVoice);
}

speechSynthesis.onvoiceschanged = setMaleVoice;
setMaleVoice();

/* ---------------------------------------------
   SPEAK FUNCTION ‚Äì TTS-LIPSYNC (OHNE MIKROFON)
   Funktioniert auch bei Render.com & Handy
--------------------------------------------- */
function speak(text, slow = false) {
  const u = new SpeechSynthesisUtterance(text);
  u.lang = "de-DE";
  u.rate = slow ? 0.4 : 0.95;
  if (maleVoice) u.voice = maleVoice;

  let lipsyncInterval = null;
  let audioCtx = null;
  let analyser = null;
  let buffer = null;

  u.onstart = () => {
    talking = true;

    // üéß AudioContext erzeugen (nur wenn n√∂tig)
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === "suspended") {
      audioCtx.resume();
    }

    // üîä Analyzer f√ºr Lautst√§rke
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    buffer = new Uint8Array(analyser.frequencyBinCount);

    // üìå KI-Stimme ‚Üí kein Mikro n√∂tig!
    // Dummy Quelle, damit der Analyser aktiv bleibt
    const osc = audioCtx.createOscillator();
    osc.connect(analyser);
    osc.start();

    // üß† Lippenbewegung: Lautst√§rke steuert Blendshapes
    lipsyncInterval = setInterval(() => {
      analyser.getByteFrequencyData(buffer);

      let sum = 0;
      for (let i = 0; i < buffer.length; i++) {
        sum += buffer[i];
      }
      const vol = sum / buffer.length / 255;  // 0‚Äì1 Pegel

      const open = Math.min(vol * 2, 1);  // verst√§rken
      setBlendshape(visemeAIndex, open);
      setBlendshape(visemeEIndex, open * 0.6);
    }, 40); // ‚âà25 FPS
  };

  u.onend = () => {
    talking = false;
    clearInterval(lipsyncInterval);

    // Mund schlie√üen
    setBlendshape(visemeAIndex, 0);
    setBlendshape(visemeEIndex, 0);
  };

  speechSynthesis.speak(u);
} // <<‚Äî WICHTIG: Block endet exakt hier

/* -----------------------------
   RESIZE
----------------------------- */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
