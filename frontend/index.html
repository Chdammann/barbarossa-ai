<!DOCTYPE html>
<html lang="de">
<head>
<link rel="icon" href="avatar.png" type="image/png">
<link rel="apple-touch-icon" href="avatar.png">
<meta name="theme-color" content="#000000">
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Frag Friedrich Barbarossa</title>
<style>
body {
  margin: 0;
  overflow: hidden;
  background-color: black;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  flex-direction: column;
  font-family: "Georgia", serif;
  color: white;
}
h1 {
  position: absolute;
  top: 20px;
  text-align: center;
  width: 100%;
  font-size: 2em;
  color: #e0b36b;
  text-shadow: 0 0 10px #000;
  letter-spacing: 2px;
  animation: pulse 3s ease-in-out infinite;
}
@keyframes pulse {
  0%,100% { transform: scale(1); opacity:1; }
  50% { transform: scale(1.05); opacity:0.9; }
}
#avatarCanvas { width: 100%; height: 100%; display: block; }
#micBtn {
  position: absolute;
  bottom: 60px;
  left: 50%;
  transform: translateX(-50%);
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background: #222;
  border: none;
  color: white;
  font-size: 32px;
  cursor: pointer;
}
#micBtn:hover { background:#444; }
</style>
</head>
<body>
<h1>Frag Friedrich</h1>
<div id="loading">Avatar wird geladenâ€¦</div>
<canvas id="avatarCanvas"></canvas>
<button id="micBtn">ðŸŽ¤</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
/* ------------------------------
    STATES
------------------------------ */
let STATE = "idle"; // idle â†’ greet â†’ listen â†’ hmmm â†’ answer â†’ idle
let lastTranscript = "";

let model, talking=false;
let greeted=false;
let hmNeigen=false, hmStartTime=0;
let rising=false, riseStartTime=0;
const hmDuration=2000, riseDuration=1200;

let baseRotY = -0.35;     // leichte Neigung nach Avatar-Rechts
let baseRotX = 0.25;
let targetRotY = baseRotY;
let targetRotX = baseRotX;
let baseY = 0;

/* ------------------------------
    THREE.JS SETUP
------------------------------ */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(30, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,0,2.8);
const renderer = new THREE.WebGLRenderer({canvas: document.getElementById("avatarCanvas"), antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(0x000000);

// Licht â€“ NICHT geÃ¤ndert!
const light = new THREE.DirectionalLight(0xffffff,2);
light.position.set(1,1,2);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff,0.8));
const frontLight = new THREE.PointLight(0xffffff,0.8);
frontLight.position.set(0,0.5,2);
scene.add(frontLight);

/* ------------------------------
    MODEL LADEN
------------------------------ */
const loader = new THREE.GLTFLoader();
const loadingText = document.getElementById("loading");

loader.load("./avatar.glb", gltf=>{
  model=gltf.scene;
  const box = new THREE.Box3().setFromObject(model);
  const size = box.getSize(new THREE.Vector3());
  const maxDim = Math.max(size.x,size.y,size.z);
  model.scale.set(1.1,1.1,1.1);
  const center = box.getCenter(new THREE.Vector3());
  model.position.sub(center);
  model.rotation.y = baseRotY - Math.PI/2; // FRONT + leicht nach RECHTS geneigt
  model.rotation.x = baseRotX;
  scene.add(model);
  loadingText.style.display="none";
  animate();
});

/* ------------------------------
    ANIMATE â€“ STATE MACHINE
------------------------------ */
function animate(){
  requestAnimationFrame(animate);
  if(model){
    // Aufrichten nach BegrÃ¼ÃŸung / Antwort (wie bisher)
    if(rising){
      const t = (performance.now() - riseStartTime) / riseDuration;
      const clamped = Math.max(0, Math.min(1, t));
      const easeT = -Math.cos(Math.PI * clamped)/2 + 0.5;  // weich ein- und ausblenden

      // von geneigt (baseRotX/Y) zu frontal (0)
      targetRotY = baseRotY * (1 - easeT);
      targetRotX = baseRotX * (1 - easeT);

      if(clamped >= 1) rising = false;
    }

    // "Hmmmâ€¦"-Phase: langsam nach vorne und Avatar-LEFT neigen
    if(hmNeigen){
      const t = (performance.now() - hmStartTime) / hmDuration;
      const clamped = Math.max(0, Math.min(1, t));
      // smoothstep fÃ¼r weiche Bewegung
      const easeT = clamped * clamped * (3 - 2 * clamped);

      const maxDown = 0.3;   // Neigung nach vorne
      const maxSide = -0.3;  // NEGATIV = andere Richtung als vorher (Avatar-links)

      model.rotation.x = hmStartRotX + maxDown * easeT;
      model.rotation.y = hmStartRotY + maxSide * easeT;

      if(clamped >= 1){
        // Zielpose erreicht, dort stehen bleiben, bis Antwort kommt
        hmNeigen = false;
      }
    }

    // Normal Talking Animation
    if(talking && !hmNeigen){
      // wÃ¤hrend der Antwort langsam Richtung targetRotY (frontal) drehen,
      // mit leichter lebendiger Bewegung
      model.rotation.y = THREE.MathUtils.lerp(
        model.rotation.y,
        targetRotY + Math.sin(Date.now()*0.0015)*0.03 - Math.PI/2,
        0.08
      );
      model.rotation.x = THREE.MathUtils.lerp(
        model.rotation.x,
        targetRotX + Math.sin(Date.now()*0.0019)*0.015,
        0.08
      );
      model.rotation.z = Math.sin(Date.now()*0.0012)*0.015;
      model.position.y = baseY + Math.sin(Date.now()*0.01)*0.002;
    } 
    // Idle / Ruhig nur dann, wenn wir NICHT in Hmmm sind UND NICHT mitten im Zyklus
    else if(!hmNeigen && !hmStarted){
      model.rotation.y = THREE.MathUtils.lerp(
        model.rotation.y,
        targetRotY - Math.PI/2,
        0.02
      );
      model.rotation.x = THREE.MathUtils.lerp(
        model.rotation.x,
        targetRotX,
        0.02
      );
      model.rotation.z = THREE.MathUtils.lerp(model.rotation.z || 0, 0, 0.02);
      model.position.y = THREE.MathUtils.lerp(model.position.y, baseY, 0.02);
    }
  }
  renderer.render(scene,camera);
}


/* ------------------------------
    SPEECH â€“ recognition
------------------------------ */
let recognition = new webkitSpeechRecognition();
recognition.lang="de-DE";
recognition.interimResults=false;
recognition.continuous=false;

recognition.onresult = e => lastTranscript = e.results[0][0].transcript;

recognition.onend = () => {
  if(STATE === "listen"){
    STATE = "hmmm";
    hmNeigen = true;
    hmStartTime = performance.now();
    speak("Hmmmm... einen Moment", true);

    // --- Antwort holen ---
    fetch("/ask", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body: JSON.stringify({ text: lastTranscript })
    })
    .then(r => r.json())
    .then(data => {
      STATE = "answer";
      speaking(data.answer);
    });
  }
};

/* ------------------------------
    SPEAKING â€“ Antwort
------------------------------ */
function speaking(text){
  rising=true;
  riseStartTime=performance.now();
  speak(text);

  setTimeout(()=>{
    // â†©ï¸Ž Nach Antwort â†’ Idle-Pose (leicht rechts geneigt)
    STATE = "idle";
    greeted = false;
    targetRotY = baseRotY;
  }, 600);
}

/* ------------------------------
    MIC BUTTON
------------------------------ */
const micBtn = document.getElementById("micBtn");
micBtn.onclick = () => {
  if(STATE === "idle"){
    STATE="greet";
    greeted=true;
    rising=true;
    riseStartTime=performance.now();
    speak("Seid gegrÃ¼ÃŸt, mein Freund! Sprecht, was begehrt Ihr?");
  }
  else if(STATE === "greet"){
    STATE="listen";
    recognition.start();
  }
};

/* ------------------------------
    VOICES
------------------------------ */
let maleVoice=null;
function loadVoices(){
  const voices=speechSynthesis.getVoices();
  maleVoice=voices.find(v=>/male|mann|stefan|markus/i.test(v.name)) ||
             voices.find(v=>v.lang.startsWith("de")) || voices[0];
}
speechSynthesis.onvoiceschanged=loadVoices;
loadVoices();

function speak(text, slow=false){
  const u=new SpeechSynthesisUtterance(text);
  u.voice=maleVoice;
  u.lang="de-DE";
  u.rate=slow?0.4:0.95;
  u.pitch=0.6;
  u.volume=0.7;
  u.onstart=()=>talking=true;
  u.onend=()=>talking=false;
  speechSynthesis.speak(u);
}
</script>
</body>
</html>
